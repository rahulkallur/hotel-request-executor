package services

import (
	model "Executor/models"
	"encoding/json"
	"sort"
	"strconv"
	"strings"
)

type SearchResponseRepository interface {
	SearchResponsetMapper(response string) model.HotelResponse
}

type searchResponseRepository struct {
}

func NewSearchResponseRepository() SearchResponseRepository {
	return &searchResponseRepository{}
}

func (s *searchResponseRepository) SearchResponsetMapper(response string) model.HotelResponse {
	// Declare variables for the result and intermediate response data.
	var result model.AutoGenerated
	var mainResult model.Resp
	var roomInfo []model.RoomInfo

	// Unmarshal the initial JSON response into the 'mainResult' struct.
	if err := json.Unmarshal([]byte(response), &mainResult); err != nil {
		return model.HotelResponse{ErrorMessage: err.Error()} // Return error message if unmarshalling fails.
	}

	// Unmarshal the SupplierResp field into 'result', which contains the hotel data.
	if err := json.Unmarshal([]byte(mainResult.SupplierResp), &result); err != nil {
		return model.HotelResponse{ErrorMessage: err.Error()} // Return error message if unmarshalling fails.
	}

	// Unmarshal the RoomInfo field into 'roomInfo', which contains room data.
	if err := json.Unmarshal([]byte(mainResult.RoomInfo), &roomInfo); err != nil {
		return model.HotelResponse{ErrorMessage: err.Error()} // Return error message if unmarshalling fails.
	}

	// Check if the result contains hotels and if there are any hotels in the list.
	if result.Hotels != nil && len(result.Hotels.Hotels) > 0 {
		// Return the mapped search results, mapping hotels and room info to hotel listings.
		return SearchResultMapper(result.Hotels, roomInfo)
	}

	// Return an error message if no hotels are found.
	return model.HotelResponse{ErrorMessage: "No Result Found", TrackerID: roomInfo[0].TrackerID} // Return error message if unmarshalling fails.
}

// SearchResultMapper maps the hotel and room data into a list of HotelListing models.
// It processes the provided hotel data and room information to generate detailed hotel listings.
func SearchResultMapper(result *model.Hotels, roominfo []model.RoomInfo) model.HotelResponse {
	// Initialize an empty slice to hold the mapped hotel listings.
	var Result []model.HotelListing

	// Iterate over each hotel in the provided Hotels list.
	for _, hotel := range result.Hotels {
		// Initialize an empty HotelListing object to store the mapped details for the current hotel.
		var resp model.HotelListing
		resp.HotelCode = strconv.Itoa(hotel.Code) // Convert hotel code to string
		resp.Name = hotel.Name                    // Set the hotel name

		// Attempt to convert latitude and longitude from strings to float64 and assign to GeoLocation.
		lat, _ := strconv.ParseFloat(hotel.Latitude, 64)
		lon, _ := strconv.ParseFloat(hotel.Longitude, 64)
		resp.GeoLocation = model.GeoLocation{Latitude: lat, Longitude: lon}

		// Map room details using the provided RoomMapping function and assign to RoomDetails.
		resp.RoomDetails = RoomMapping(hotel.Rooms, roominfo, hotel.Currency)
		// Append the mapped hotel listing to the result slice.
		Result = append(Result, resp)
	}

	// Return the slice containing all the mapped hotel listings.
	return model.HotelResponse{TrackerID: roominfo[0].TrackerID, HotelListing: Result}
}

// RoomMapping processes and maps the provided room details, room information, and currency data
// into a list of RoomGroup objects. It handles the transformation of room data by
// organizing, sorting, and grouping rooms, then returns the final RoomRatePlan groups
func RoomMapping(roomDetails []model.Room, roominfo []model.RoomInfo, currency string) []model.RoomGroup {
	var requestedRooms = GetRequestedRoomsSorted(roominfo)
	var roomContainers = GetRoomContainers(roomDetails)
	var roomListContainers = CombineRooms(requestedRooms, roomContainers, roominfo)
	var roomRatePlanGroups = CreateRoomRatePlanGroups(roomListContainers, requestedRooms, currency)
	return roomRatePlanGroups
}

// GetRequestedRoomsSorted returns a sorted list of Pax keys
func GetRequestedRoomsSorted(roominfo []model.RoomInfo) []string {
	var rooms []string

	for i, room := range roominfo {
		key := CreatePaxString(room.Adult, room.ChildAge)
		room.PaxKey = key
		rooms = append(rooms, key)
		roominfo[i] = room
	}

	// Sort the rooms slice
	sort.Strings(rooms)

	return rooms
}

// CreatePaxString creates a Pax key string based on adults and child ages
func CreatePaxString(adults int, childAges []int) string {
	// Start the Pax string with the number of adults
	paxes := strconv.Itoa(adults)

	// If there are child ages, append them to the Pax string
	if len(childAges) > 0 {
		for _, childAge := range childAges {
			paxes += "," + strconv.Itoa(childAge)
		}
	}

	return paxes
}

// GetRoomContainers converts hotel response data into RoomContainers, sorts and groups them
func GetRoomContainers(hotelBedsResponseRooms []model.Room) []model.RoomContainer {
	var roomContainers []model.RoomContainer
	rateDisc := make(map[string]bool)

	// Iterate through the response rooms
	for _, hotelBedsResponseRoom := range hotelBedsResponseRooms {
		// Iterate through the rates
		for _, rate := range hotelBedsResponseRoom.Rates {
			if _, exists := rateDisc[rate.RateKey]; !exists {
				// Map room and add to the container list
				roomContainer := MapRoom(hotelBedsResponseRoom, rate)
				roomContainers = append(roomContainers, roomContainer)
				// Mark this rate as processed
				rateDisc[rate.RateKey] = true
			}
		}
	}

	// Sort by SortKey first, then by price within the SortKey groups
	sort.SliceStable(roomContainers, func(i, j int) bool {
		// First compare SortKey
		if roomContainers[i].SortKey != roomContainers[j].SortKey {
			return roomContainers[i].SortKey < roomContainers[j].SortKey
		}
		// Then compare the price of the first room in the group (assuming at least one room)
		if roomContainers[i].Room.Adult > 0 {
			return roomContainers[i].Room.Price < roomContainers[j].Room.Price
		}
		return false
	})

	// Grouping by SortKey
	grouped := make(map[string][]model.RoomContainer)
	for _, container := range roomContainers {
		grouped[container.SortKey] = append(grouped[container.SortKey], container)
	}

	// Flatten the grouped list into sorted containers
	var sortedContainers []model.RoomContainer
	for _, group := range grouped {
		sortedContainers = append(sortedContainers, group...)
	}

	return sortedContainers
}

// MapRoom is a placeholder function to map the hotel and rate to a RoomContainer
func MapRoom(hotelBedsResponseRoom model.Room, rate model.Rate) model.RoomContainer {
	var childAges = GetChildAges(rate)
	var paxString = CreatePaxString(rate.Adults, childAges)
	return model.RoomContainer{
		SortKey:    paxString,
		Room:       CreateRoom(hotelBedsResponseRoom, rate),
		Paxes:      paxString,
		Allotment:  rate.Allotment,
		BoardCode:  rate.BoardCode,
		Refundable: rate.RateClass != "NRF",
	}
}

func GetChildAges(rate model.Rate) []int {
	if rate.Children > 0 {
		ages := []int{}
		split := strings.Split(rate.ChildrenAges, ",")
		for _, age := range split {
			// Remove any extra spaces and parse the age
			trimmedAge := strings.TrimSpace(age)
			if trimmedAge != "" {
				ageInt, err := strconv.Atoi(trimmedAge)
				if err == nil {
					ages = append(ages, ageInt)
				}
			}
		}
		return ages
	}
	return nil
}

// CreateRoom creates a RoomDetails object based on hotel and rate information.
func CreateRoom(hotelBedsResponseRoom model.Room, rate model.Rate) model.RoomDetails {
	// Initialize the RoomDetails struct
	roomsItem := model.RoomDetails{
		RoomName:   hotelBedsResponseRoom.Name, // Set the room name
		Adult:      rate.Adults,                // Set the number of adults
		Child:      rate.Children,              // Set the number of children
		BoardName:  rate.BoardName,             // Set the board name (e.g., breakfast)
		Refundable: rate.RateClass != "NRF",    // Set refundable status based on RateClass
	}

	// If there are children, parse and add their ages
	if rate.ChildrenAges != "" {
		// Split the ages string and iterate over it
		for _, ageStr := range strings.Split(rate.ChildrenAges, ",") {
			ageStr = strings.TrimSpace(ageStr) // Trim any whitespace
			if ageInt, err := strconv.Atoi(ageStr); err == nil {
				roomsItem.ChildAge = append(roomsItem.ChildAge, ageInt) // Append valid child age
			}
		}
	}

	// Convert the rate net value to a float64 for the room price
	if floatValue, err := strconv.ParseFloat(rate.Net, 64); err == nil {
		roomsItem.Price = floatValue
	}

	return roomsItem
}

// CombineRooms combines requested rooms, room containers, and room info
// to create a unified list of room rate plan groups.
func CombineRooms(
	requestedRooms []string,
	roomContainers []model.RoomContainer,
	searchHotelRequest []model.RoomInfo,
) []model.RoomListContainer {
	var roomListContainers []model.RoomListContainer
	firstRequestedRoom := requestedRooms[0]

	for i := 0; i < len(roomContainers); i++ {
		roomContainer := roomContainers[i]
		if roomContainer.Paxes == firstRequestedRoom {
			if len(requestedRooms) > 1 {
				roomListContainer := model.RoomListContainer{
					BoardCode: roomContainer.BoardCode,
				}
				roomListContainer.AddRoomContainer(roomContainer)
				FindAdditionalMatchingRooms(requestedRooms, i, roomContainers, roomContainer, &roomListContainer)

				if len(requestedRooms) == len(roomListContainer.RoomContainers) {
					roomContainerItem := model.RoomListContainer{
						RoomTypeCode: roomListContainer.RoomTypeCode,
						BoardCode:    roomListContainer.BoardCode,
						RoomCode:     roomListContainer.RoomCode,
					}

					for _, searchRoom := range searchHotelRequest {
						index := findIndex(roomListContainer.RoomContainers, func(c model.RoomContainer) bool {
							return c.Paxes == searchRoom.PaxKey && !c.UsedInMerging
						})

						if index >= 0 {
							sortedRoomContainer := roomListContainer.RoomContainers[index]
							sortedRoomContainer.UsedInMerging = true
							roomContainerItem.AddRoomContainer(sortedRoomContainer)
						}
					}

					roomListContainers = append(roomListContainers, roomContainerItem)
				}
			} else {
				roomListContainer := model.RoomListContainer{
					BoardCode: roomContainer.BoardCode,
				}
				roomListContainer.AddRoomContainer(roomContainer)
				roomListContainers = append(roomListContainers, roomListContainer)
			}
		}
	}

	return roomListContainers
}

// FindAdditionalMatchingRooms adds additional matching rooms to the room list container
func FindAdditionalMatchingRooms(
	requestedRooms []string,
	roomContainerIndex int,
	roomContainers []model.RoomContainer,
	roomContainer model.RoomContainer,
	roomListContainer *model.RoomListContainer,
) {
	for j := 1; j < len(requestedRooms); j++ {
		for roomCounter := roomContainerIndex; roomCounter < len(roomContainers); roomCounter++ {
			roomContainerOption := roomContainers[roomCounter]
			if roomContainerOption.Paxes == requestedRooms[j] &&
				roomContainerOption.BoardCode == roomContainer.BoardCode &&
				roomContainerOption.Refundable == roomContainer.Refundable {
				if roomContainer.Allotment >= 1 {
					roomContainerOptionItem := model.RoomContainer{
						BoardCode:     roomContainerOption.BoardCode,
						Refundable:    roomContainerOption.Refundable,
						Paxes:         roomContainerOption.Paxes,
						Allotment:     roomContainerOption.Allotment,
						Room:          roomContainerOption.Room,
						UsedInMerging: false,
					}
					roomListContainer.AddRoomContainer(roomContainerOptionItem)
					roomContainer.Allotment--
					break
				}
			}
		}
	}
}

// Helper function to find the index of the first matching element
func findIndex(containers []model.RoomContainer, predicate func(model.RoomContainer) bool) int {
	for i, container := range containers {
		if predicate(container) {
			return i
		}
	}
	return -1
}

// CreateRoomRatePlanGroups creates room rate plan groups by combining room list containers, requested rooms, and currency.
// It calculates the total price for each group and returns the consolidated room details.
func CreateRoomRatePlanGroups(roomListContainers []model.RoomListContainer, requestedRooms []string, currency string) []model.RoomGroup {
	roomRatePlanGroups := []model.RoomGroup{}
	for _, roomListContainer := range roomListContainers {
		if len(roomListContainer.RoomContainers) != len(requestedRooms) {
			continue
		}
		total := 0.0
		for _, v := range roomListContainer.RoomContainers {
			total += v.Room.Price
		}
		roomGroup := model.RoomGroup{
			RoomDetails: []model.RoomDetails{},
			Price:       total,
			Currency:    currency,
		}

		for _, roomContainer := range roomListContainer.RoomContainers {
			roomGroup.RoomDetails = append(roomGroup.RoomDetails, roomContainer.Room)
		}
		roomRatePlanGroups = append(roomRatePlanGroups, roomGroup)
	}
	return roomRatePlanGroups
}
